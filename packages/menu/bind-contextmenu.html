<template component>
  <style>
    :host {
      display: block;
      position: relative;
    }
  </style>
  <slot></slot>
  <script>
    export default async ({ load }) => {
      const { areas } = await load("./menu-area.html");

      // 全局只能有一个右键菜单
      let onlyMenu = null;

      return {
        tag: "p-bind-contextmenu",
        attrs: {
          area: null,
          autoClose: null,
        },
        ready() {
          this.shadow.on("slotchange", () => {
            // 防止菜单内的右键触发
            this.forEach((e) => {
              if (!e.is("p-menu") || e.__stopBubble) {
                return;
              }

              e.__stopBubble = true;
              e.on("contextmenu", (e) => e.stopPropagation());
            });
          });
        },
        attached() {
          this.all("p-menu").forEach((e) => (e.open = "off"));

          this.on("click-menu-item", (e) => {
            // 如果设置了autoClose，且点击的元素不是菜单，则自动关闭菜单
            if (
              this.autoClose !== null &&
              !$(e.target).some((e) => e.tag === "p-menu")
            ) {
              this.all("p-menu").forEach((e) => (e.open = "off"));
            }
          });

          this.on("contextmenu", (e) => {
            const $target = $(e.target);
            e.preventDefault();
            e.stopPropagation();

            // 目标菜单元素
            let targetMenu;

            this.forEach((menu) => {
              const contextmenuSelector = menu.attr("contextmenu-selector");
              if (menu.is("p-menu")) {
                if (contextmenuSelector && $target.is(contextmenuSelector)) {
                  targetMenu = menu;
                }

                // menu.open = "off";
              }
            });

            if (!targetMenu) {
              // 保底菜单元素
              targetMenu = this.$("p-menu");
            }

            if (onlyMenu && onlyMenu !== targetMenu) {
              onlyMenu.open = "off";
            }

            targetMenu.open = "";
            onlyMenu = targetMenu;

            const { offsetX, offsetY, clientX, clientY } = e;

            Object.assign(targetMenu.style, {
              position: "absolute",
              left: `${offsetX}px`,
              top: `${offsetY}px`,
            });

            // 获取安全容器的尺寸和位置
            const targetArea = this.area ? areas.get(this.area) : null;

            const {
              left: areaLeft,
              top: areaTop,
              width: areaWidth,
              height: areaHeight,
            } = targetArea
              ? targetArea.ele.getBoundingClientRect()
              : this.ele.getBoundingClientRect();

            // 菜单的尺寸和位置
            const {
              width: menuWidth,
              height: menuHeight,
              left: menuLeft,
              top: menuTop,
            } = targetMenu.ele.getBoundingClientRect();

            // 菜单超出下方安全区域，修正为下方定位
            if (menuTop + menuHeight > areaTop + areaHeight) {
              targetMenu.style.top = `${
                parseInt(targetMenu.style.top) - menuHeight
              }px`;
            }

            // 菜单超出右方安全区域，修正为右侧定位
            if (menuLeft + menuWidth > areaLeft + areaWidth) {
              targetMenu.style.left = `${
                parseInt(targetMenu.style.left) - menuWidth
              }px`;
            }

            // 修正二级菜单的定位
            targetMenu.all("p-menu").forEach((menu) => {
              // 先还原定位
              Object.assign(menu.style, {
                left: "",
                top: "",
              });

              const {
                width: subMenuWidth,
                height: subMenuHeight,
                left: subMenuLeft,
                top: subMenuTop,
              } = menu.ele.getBoundingClientRect();

              // 超出右侧的范围，放在左侧
              if (subMenuLeft + subMenuWidth > areaLeft + areaWidth) {
                menu.style.left = `-${subMenuWidth}px`;
              }

              // 超出下方的范围，放在上方
              if (subMenuTop + subMenuHeight > areaTop + areaHeight) {
                menu.style.top = `-${subMenuHeight - menu.parent.height}px`;
              }
            });
          });

          if (!this._bindFn) {
            this._bindFn = () => {
              this.all("p-menu").forEach((menu) => {
                menu.open = "off";
              });

              $("html").off("mouseup", this._bindFn);
              this._bindFn = null;
            };

            // 点击外部环境后，取消菜单绑定
            $("html").on("click", this._bindFn);
          }
        },
        detached() {
          if (this._bindFn) {
            $("html").off("mouseup", this._bindFn);
          }
        },
      };
    };
  </script>
</template>
