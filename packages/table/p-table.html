<template component>
  <l-m src="./p-table-row.html"></l-m>
  <l-m src="./p-table-cell.html"></l-m>
  <style>
    :host {
      position: relative;
      display: block;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: auto;
      padding: var(--pui-space-y) 0;
      color: var(--md-sys-color-on-normal-container);
      border-radius: var(--pui-border-radius);
      box-shadow: var(--contained-shadow);
      background-color: var(--md-sys-color-on-normal);
      font-size: 14px;
    }

    ::slotted(p-table-row:last-child) {
      border-bottom: none;
    }
  </style>
  <div class="container" on:scroll="bodyResize">
    <slot></slot>
  </div>
  <script>
    export default {
      data: {},
      proto: {
        refreshSlefStyle() {
          clearTimeout(this.__refreshStyleTimer);
          this.__refreshStyleTimer = setTimeout(() => {
            const headRow = this.$("p-table-row[head]");
            let styleStr = "";
            const cellLength = headRow.length;
            const { width } = this;
            // reload width
            const cellWidth = width / cellLength;

            console.log(cellWidth);

            styleStr += `p-table[data-table-id="${this._tableId}"] p-table-cell{flex:1 1 ${cellWidth}px;}`;

            headRow.forEach((e, index) => {
              let colStyle = "";

              if (e.align) {
                let jc = "";

                switch (e.align) {
                  case "center":
                    jc = "center";
                    break;
                  case "right":
                    jc = "flex-end";
                    break;
                  case "left":
                    jc = "flex-start";
                    break;
                }

                colStyle += `text-align:${e.align};justify-content:${jc};`;
              }

              if (e.colWidth) {
                colStyle += `flex:0 0 ${e.colWidth}`;
              }

              if (e.grow !== null) {
                colStyle += `flex-grow:${e.grow};`;
              }

              if (e.shrink !== null) {
                colStyle += `flex-shrink:${e.shrink};`;
              }

              if (e.minWidth) {
                colStyle += `min-width:${e.minWidth}`;
              }
              if (e.maxWidth) {
                colStyle += `max-width:${e.maxWidth}`;
              }

              if (colStyle) {
                styleStr += `p-table[data-table-id="${
                  this._tableId
                }"] p-table-cell:nth-child(${index + 1}){${colStyle}}`;
              }
            });
            this.__currentStyle.html = styleStr;
          }, 100);
        },
        bodyResize(e) {
          const container = this.shadow.$(".container");
          const left = container.ele.scrollLeft;

          const headRow = this.$(`p-table-row[head][sticky]`);
          if (headRow) {
            headRow.scrollLeft = left;
          }

          // console.log("scroll => ", left, headRow);
        },
      },
      ready() {
        const tid = (this._tableId = Math.random().toString(32).slice(2));
        this.attr("data-table-id", tid);

        this.on("change-cell-prop", () => {
          this.refreshSlefStyle();
        });
      },
      attached() {
        const currentStyle = $(`<style table-id="${this._tableId}"></style>`);
        this.__currentStyle = currentStyle;
        const par = this.root.$("head") || this.root;
        par.push(currentStyle);

        window.addEventListener(
          "resize",
          (this._resizeFun = (e) => {
            this.refreshSlefStyle();
          })
        );
      },
      detached() {
        clearTimeout(this.__refreshStyleTimer);
        this.__currentStyle.remove();

        window.removeEventListener("resize", this._resizeFun);
      },
    };
  </script>
</template>
