<template component>
  <l-m src="../wave/wave.html"></l-m>
  <style>
    :host {
      display: block;
      --item-radio: 30px;
    }
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: stretch;
      /* overflow: auto; */
      overflow: hidden;
    }

    ::slotted(*) {
      position: relative;
      flex: 0 0 0;
      border-radius: var(--item-radio);
      cursor: pointer;
      overflow: hidden;
      color: transparent;
      /* transition: all ease 0.3s; */
      transition: margin ease 0.3s;
    }

    ::slotted(*:last-child) {
      margin-right: 0 !important;
    }

    ::slotted([focus]) {
      color: inherit;
      outline: green solid 4px;
    }
    .prev,
    .next {
      position: absolute;
      top: 40%;
      z-index: 2;
    }
    .prev {
      left: 0;
    }
    .next {
      right: 0;
    }
  </style>

  <inject-host>
    <style>
      p-carousel[add-anime] > * {
        transition: all ease 0.3s;
      }
    </style>
  </inject-host>
  <div class="container">
    <slot></slot>
    <button class="prev" on:click="currentId--">prev</button>
    <button class="next" on:click="currentId++">next</button>
  </div>
  <script>
    export default {
      tag: "p-carousel",
      attrs: {
        mainBasis: null, // 焦点窗口的大小
        activeIndex: "0", // 激活中的id
        align: "start", // start 左侧第一个为主要块；center 主要块为中间那个
      },
      data: {
        spaceSize: 6,
        smallBasis: 60, //小块的尺寸
      },
      watch: {
        activeIndex() {
          if (this.currentId < 0) {
            this.currentId = 0;
            return;
          }

          if (this.currentId >= this.length) {
            this.currentId = this.length - 1;
            return;
          }
          this.render(this.currentId);
        },
      },
      proto: {
        get currentId() {
          return parseInt(this.activeIndex) || 0;
        },
        set currentId(val) {
          this.activeIndex = String(val);
        },
        // 根据index进度渲染页面
        render(precent) {
          if (precent < 0) {
            precent = 0;
          } else if (precent >= this.length) {
            precent = this.length - 1;
          }

          const activeId = Math.floor(precent);
          console.log(precent, activeId);
          // const activeId = Math.ceil(precent);
          const diffPrecent = precent - activeId;

          // 计算激活宽度
          let mainBasis = parseInt(this.mainBasis);

          if (/%$/.test(this.mainBasis)) {
            mainBasis = (this.width * parseInt(mainBasis)) / 100;
          }

          if (!mainBasis) {
            return;
          }

          // 可以共存的个数
          let activeLen = Math.floor(this.width / mainBasis);

          // 视觉上的最后一个id
          // const lastVisoId = this.length - activeLen;

          // 剩余的尺寸
          const oversize =
            this.width - activeLen * (mainBasis + this.spaceSize);

          // 向前修正的个数
          let fixPrevLen = 0;
          // 修正的激活id个数
          let targetId = activeId;

          this.all("[visible]").forEach((e) => {
            e.style.flexBasis = "";
            e.style.marginRight = "";
          });

          const oldFocus = this.$("[focus]");

          if (oldFocus) {
            oldFocus.attr("focus", null);
          }

          this[activeId].attr("focus", "");

          for (let i = activeLen; i > 0; i--) {
            const target = this[targetId];

            if (target) {
              target.style.flexBasis = `${mainBasis}px`;
              target.style.marginRight = `${this.spaceSize}px`;
              target.attr("visible", "");
            } else {
              fixPrevLen++;
            }

            targetId++;
          }

          let fixedActiveId = activeId;
          if (fixPrevLen) {
            // 向前面修补数量
            for (let i = fixPrevLen; i > 0; i--) {
              fixedActiveId--;
              const target = this[fixedActiveId];

              target.style.flexBasis = `${mainBasis}px`;
              target.style.marginRight = `${this.spaceSize}px`;

              target.attr("visible", "");
            }
          }

          // 最前面的一个元素
          const startBlock = this[fixedActiveId];
          // 最后面的元素
          const endBlock = this[targetId];

          console.log("startBlock", startBlock.ele);
          console.log("endBlock", endBlock?.ele);

          if (!endBlock) {
            // 后面没有元素，修正前一个元素
            startBlock.prev.style.flexBasis = `${oversize}px`;
            startBlock.prev.style.marginRight = `${this.spaceSize}px`;
            startBlock.prev.attr("visible", "");
          } else {
            let nWidth = oversize + mainBasis * (1 - diffPrecent);

            if (nWidth > mainBasis) {
              const { prev } = startBlock;
              if (prev) {
                prev.style.flexBasis = `${
                  nWidth - mainBasis - this.spaceSize
                }px`;
                prev.style.marginRight = `${this.spaceSize}px`;
                prev.attr("visible", "");
              }
              // debugger;
            }

            startBlock.style.flexBasis = `${
              nWidth > mainBasis ? mainBasis : nWidth
            }px`;

            endBlock.style.flexBasis = `${
              mainBasis - mainBasis * (1 - diffPrecent)
            }px`;
          }
          // console.log(mainBasis, activeLen, oversize, activeId, diffPrecent);
        },
      },
      ready() {
        this.attr("add-anime", "");

        // fix p-wave
        this.shadow.on("slotchange", () => {
          this.forEach((e) => {
            if (!e.$("p-wave")) {
              e.push({ tag: "p-wave" });
            }
          });
        });

        let diffWidth = 0;

        // this.on("touchstart", (e) => {
        //   console.log("touchstart", e);
        // });
        // this.on("gestureend", (e) => {
        //   console.log("gestureend", e);
        // });

        let timer;

        this.on("wheel", (e) => {
          if (Math.abs(e.deltaX) > 0) {
            e.preventDefault();
          }

          diffWidth += e.deltaX;

          // console.log(diffWidth, diffWidth / 500);

          let newIndex = this.currentId + diffWidth / 500;
          const notRun = newIndex < 0 || newIndex >= this.length - 1;

          if (notRun) {
            this.attr("add-anime", "");
          } else {
            this.attr("add-anime", null);
          }

          this.render(newIndex);

          clearTimeout(timer);
          timer = setTimeout(
            () => {
              this.attr("add-anime", "");
              diffWidth = 0;

              let id;
              if (newIndex > 0) {
                id = this.currentId = Math.floor(newIndex);
              } else {
                id = this.currentId = Math.ceil(newIndex);
              }

              this.render(id);
            },
            notRun ? 0 : 100
          );
        });
      },
      attached() {
        this.render(this.currentId);
      },
    };
  </script>
</template>
